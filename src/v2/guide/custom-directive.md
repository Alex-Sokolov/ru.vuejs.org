---
title: Пользовательские директивы
type: guide
order: 16
---

## Введение

Помимо встроенных директив (таких как `v-model` и `v-show`), Vue позволяет использовать ваши собственные. При этом важно понимать, что основным механизмом создания повторно используемого кода во Vue 2.0 всё-таки являются компоненты. Тем не менее, для выполнения низкоуровневых операций с DOM пользовательские директивы могут очень пригодится. В нашем примере мы рассмотрим элемент input:

{% raw %}
<div id="simplest-directive-example" class="demo">
  <input v-focus>
</div>
<script>
Vue.directive('focus', {
  inserted: function (el) {
    el.focus()
  }
})
new Vue({
  el: '#simplest-directive-example'
})
</script>
{% endraw %}

После загрузки страницы это элемент получает фокус ввода. Если вы никуда не кликнули с момента открытия этой главы руководства, фокус ввода и сейчас должен быть на этом элементе. Рассмотрим директиву подробнее:

``` js
// Регистрируем глобальную пользовательскую директиву v-focus
Vue.directive('focus', {
  // Когда привязанный элемент вставлен в DOM...
  inserted: function (el) {
    // Получить фокус ввода
    el.focus()
  }
})
```

Если вместо глобальной вы хотели бы зарегистрировать локальную директиву, можно использовать опцию `directives` при определении компонента:

``` js
directives: {
  focus: {
    // определение директивы
  }
}
```

Затем в шаблонах можно использовать новосозданный атрибут `v-focus`, на любом элементе:

``` html
<input v-focus>
```

## Обработчики

Для жизненного цикла директивы можно указать следующие обработчики (все они, разумеется, необязательны):

- `bind`: вызывается однократно, при первичном связывании директивы с элементом. Здесь можно поместить код инициализации.

- `inserted`: вызывается после вставки связанного элемента внутрь элемента родителя (заметьте, что сам родитель может на этот момент и не принадлежать ещё основному дереву элементов)

- `update`: вызывается после обновления компонента-контейнера, __но, возможно, до обновления дочерних элементов__. Значение директивы к этому моменту может измениться, а может и нет. Сравнивая текущее и прошлое значения, вы можете избежать избыточных операций (см. ниже об аргументах обработчиков).

- `componentUpdated`: вызывается после обновления как компонента-контейнера, __так и его потомков__.

- `unbind`: вызывается однократно, при отвязывании директивы от элемента.

В следующем разделе мы рассмотрим аргументы, передаваемые в эти обработчики (а именно, `el`, `binding`, `vnode` и `oldVnode`).

## Аргументы обработчиков

В обработчики передаются следующие параметры:

- **el**: Элемент, к которому привязана директива. Можно использовать для прямых манипуляций с DOM.
- **binding**: Объект, содержащий следующие свойства:
  - **name**: Название директивы, без указания префикса `v-`.
  - **value**: Значение, переданное в директиву. Например, для `v-my-directive="1 + 1"` значением будет `2`.
  - **oldValue**: Предыдущее переданное в директиву значение. Доступно только для обработчиков `update` и `componentUpdated` и передаётся независимо от того, произошло ли в действительности его изменение.
  - **expression**: Выражение-строка, переданное в директиву. Например, для `v-my-directive="1 + 1"` это будет `"1 + 1"`.
  - **arg**: Аргумент, переданный в директиву, в случае его наличия. Например, для `v-my-directive:foo` это будет `"foo"`.
  - **modifiers**: Объект, содержащий модификаторы, если они есть. Например, для `v-my-directive.foo.bar`, объектом модификаторов будет `{ foo: true, bar: true }`.
- **vnode**: Виртуальный элемент, созданный компилятором Vue. См. [VNode API](../api/#VNode-Interface) для подробностей.
- **oldVnode**: Предыдущий виртуальный элемент, доступный только для обработчиков `update` и `componentUpdated`.

<p class="tip">Все аргументы кроме `el` следует использовать только для чтения, никогда их не модифицируя. В случае необходимости передать информацию между обработчиками, это рекомендуется делать при помощи [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset).</p>

Приведём пример пользовательской директивы, использующей некоторые из описанных возможностей:

``` html
<div id="hook-arguments-example" v-demo:hello.a.b="message"></div>
```

``` js
Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +
      'value: '      + s(binding.value) + '<br>' +
      'expression: ' + s(binding.expression) + '<br>' +
      'argument: '   + s(binding.arg) + '<br>' +
      'modifiers: '  + s(binding.modifiers) + '<br>' +
      'vnode keys: ' + Object.keys(vnode).join(', ')
  }
})

new Vue({
  el: '#hook-arguments-example',
  data: {
    message: 'hello!'
  }
})
```

{% raw %}
<div id="hook-arguments-example" v-demo:hello.a.b="message" class="demo"></div>
<script>
Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +
      'value: '      + s(binding.value) + '<br>' +
      'expression: ' + s(binding.expression) + '<br>' +
      'argument: '   + s(binding.arg) + '<br>' +
      'modifiers: '  + s(binding.modifiers) + '<br>' +
      'vnode keys: ' + Object.keys(vnode).join(', ')
  }
})
new Vue({
  el: '#hook-arguments-example',
  data: {
    message: 'hello!'
  }
})
</script>
{% endraw %}

## Сокращённая функциональная запись

Зачастую может оказаться, что используются только обработчики `bind` и `update`, причём с одним и тем же функционалом. В таком случае можно сократить запись, передав функцию напрямую:

``` js
Vue.directive('color-swatch', function (el, binding) {
  el.style.backgroundColor = binding.value
})
```

## Передача в директиву объекта

В случае, если директива должна принимать несколько параметров, можно указать объект JavaScript — годится любое валидное выражение, помните?

``` html
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
```

``` js
Vue.directive('demo', function (el, binding) {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text)  // => "hello!"
})
```
