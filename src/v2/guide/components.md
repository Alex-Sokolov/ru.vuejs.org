---
title: Компоненты
type: guide
order: 11
---

## Что такое компонент?

Одна из самых мощных возможностей Vue -- это компоненты. Компоненты расширяют базовые HTML-элементы, позволяя инкапсулировать повторно используемый код. Не вдаваясь в подробности, можно сказать, что компоненты -- это пользовательские элементы, к которым компилятор Vue привязывает определенное поведение. В некоторых случаях компоненты также задаются с помощью нативных элементов, расширенных специальным атрибутом `is`.

## Использование компонентов

### Регистрация

В предыдущих разделах мы научились создавать инстансы Vue:

``` js
new Vue({
  el: '#some-element',
  // опции
})
```

Зарегистрировать глобальный компонент можно с помощью `Vue.component(tagName, options)`:

``` js
Vue.component('my-component', {
  // опции
})
```

<p class="tip">Обратите внимание, что Vue не требует соблюдения [правил W3C](http://www.w3.org/TR/custom-elements/#concepts) для пользовательских имён тегов (таких как требования использования только нижнего регистра и применения дефисов), хотя следование этим соглашениям считается хорошей практикой.</p>

Зарегистрированный компонент можно использовать в шаблоне инстанса как пользовательский элемент `<my-component></my-component>`. Компонент обязательно должен быть зарегистрирован **до создания корневого инстанса Vue**. Вот полный пример:

``` html
<div id="example">
  <my-component></my-component>
</div>
```

``` js
// регистрация
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})

// создание корневого инстанса
new Vue({
  el: '#example'
})
```

Результатом рендера будет:

``` html
<div id="example">
  <div>Пользовательский компонент!</div>
</div>
```

{% raw %}
<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})
new Vue({ el: '#example' })
</script>
{% endraw %}

### Локальные компоненты

Необязательно регистрировать все компоненты глобально. Можно сделать компонент доступным только в области видимости другого инстанса или компонента, зарегистрировав его через опцию `components`:

``` js
var Child = {
  template: '<div>Пользовательский компонент!</div>'
}

new Vue({
  // ...
  components: {
    // <my-component> будет доступен только в шаблоне родителя
    'my-component': Child
  }
})
```

Аналогичные принципы инкапсуляции применимы и для всех остальных регистрируемых пользовательских расширений Vue, например для директив.

### Особенности парсинга DOM-шаблона

Если в качестве шаблона используется DOM (то есть в опции `el` указана точка монтирования, уже содержащая контент), то это накладывает определенные ограничения, обусловленные самим механизмом работы HTML. Выходит, что Vue получает содержимое шаблона только **после** того, как браузер распарсит и нормализует DOM. Более всего заметны ограничения использования таких элементов как `<ul>`, `<ol>`, `<table>` и `<select>` в части того, какие элементы могут находиться внутри них. Для некоторых других элементов, например для `<option>`, подобным же образом ограничен список возможных родительских элементов.

Вместе с такими элементами пользовательские компоненты могут работать некорректно. Рассмотрим пример:

``` html
<table>
  <my-row>...</my-row>
</table>
```

Пользовательский компонент `<my-row>` будет отброшен браузером как некорректный, что в конечном итоге приведет к ошибке во время рендера. Обойти эту проблему можно используя специальный атрибут `is`:

``` html
<table>
  <tr is="my-row"></tr>
</table>
```

**Стоит заметить, что эти ограничения не действуют, если в качестве шаблонов используются следующие источники**:

- `<script type="text/x-template">`
- inline-строки JavaScript
- `.vue`-компоненты

Поэтому мы советуем, по возможности, всегда использовать строковые шаблоны.

### `data` должна быть функцией

Большая часть опций, которые можно передать в конструктор Vue, могут быть использованы и в компоненте, с одним важным замечанием: `data` должна быть функцией. В действительности, если вы попробуете выполнить такой код:

``` js
Vue.component('my-component', {
  template: '<span>{{ message }}</span>',
  data: {
    message: 'привет!'
  }
})
```

Vue остановится и выведет в консоль предупреждение, говорящее о том что `data` в компонентах должна быть функцией. Тем не менее, неплохо бы понимать, почему существуют такие правила — так что давайте немного схитрим:

``` html
<div id="example-2">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
```

``` js
var data = { counter: 0 }

Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  // технически data является функцией, так что Vue
  // не будет жаловаться, но эта функция неизменно
  // возвращает ссылку на один и тот же внешний объект
  data: function () {
    return data
  }
})

new Vue({
  el: '#example-2'
})
```

{% raw %}
<div id="example-2" class="demo">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
<script>
var data = { counter: 0 }
Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return data
  }
})
new Vue({
  el: '#example-2'
})
</script>
{% endraw %}

Поскольку все три инстанса компонента используют один и тот же объект `data`, инкремент одного из счётчиков инкрементирует их все — упс! Давайте исправим это, возвращая каждый раз свежий объект data:

``` js
data: function () {
  return {
    counter: 0
  }
}
```

Теперь у всех наших счётчиков есть их собственное внутреннее состояние:

{% raw %}
<div id="example-2-5" class="demo">
  <my-component></my-component>
  <my-component></my-component>
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  }
})
new Vue({
  el: '#example-2-5'
})
</script>
{% endraw %}

### Композиция компонентов

Компоненты созданы для совместного использования, в основном в рамках отношений родитель-потомок: компонент А может использовать компонент Б в своём собственном шаблоне. В таком раскладе неизбежно появляется необходимость в коммуникации компонентов друг с другом: родителю может понадобиться передать данные в дочерний компонент, а ему, в свою очередь, может понадобиться проинформировать родителя о том, что что-то произошло. Вместе с тем, очень важно минимизировать взаимное влияние компонентов друг на друга. Для этого требуется иметь ясно определённый интерфейс взаимодействия, позволяющий удостовериться, что код каждого компонента может быть написан и проанализирован в условиях относительной изоляции. Это упрощает поддержку и потенциально облегчает повторное использование компонентов.

Во Vue.js, отношения родитель-потомок могут быть кратко просуммированы формулой **входные параметры — вниз, события — вверх ("props down, events up")**. Родитель передаёт данные потомку через **входные параметры (props)**, а дочерний компонент посылает сообщения родителю посредством **событий (events)**. Давайте посмотрим как это работает.

<p style="text-align: center">
  <img style="width:300px" src="/images/props-events.png" alt="props down, events up">
</p>

## Входные параметры

### Передача данных через входные параметры

Каждый инстанс компонента имеет свою собственную **изолированную область видимости**. Это значит, что вы не можете (и вам не стоит) напрямую обращаться к данным родительского компонента из шаблона дочернего компонента. Данные можно передавать вниз по цепочке **входных параметров**.

Входной параметр — это пользовательский атрибут для передачи информации из родительского компонента. Дочерний компонент должен явно определить ожидаемые входные параметры, используя [опцию `props`](../api/#props)

``` js
Vue.component('child', {
  // определяем входной параметр
  props: ['message'],
  // как и другие данные, входной параметр можно использовать
  // внутри шаблонов (а также и в методах, обращаясь через this.message)
  template: '<span>{{ message }}</span>'
})
```

Мы можем передать в компонент строку, например так:

``` html
<child message="привет!"></child>
```

Результатом будет:

{% raw %}
<div id="prop-example-1" class="demo">
  <child message="привет!"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['message'],
      template: '<span>{{ message }}</span>'
    }
  }
})
</script>
{% endraw %}

### camelCase против kebab-case

Атрибуты HTML являются регистронезависимыми, так что **при использовании в DOM в качестве шаблона** вместо camelCase-версий имён входных параметров приходится применять их kebab-case эквиваленты (разделять слова дефисом):

``` js
Vue.component('child', {
  // camelCase в JavaScript
  props: ['myMessage'],
  template: '<span>{{ myMessage }}</span>'
})
```

``` html
<!-- kebab-case в HTML -->
<child my-message="привет!"></child>
```

Впрочем, строковые шаблоны не накладывают и этого ограничения.

### Динамические входные параметры

Подобно связыванию обычных атрибутов, допустимо и динамическое связывание входных параметров с данными родительского компонента. Любое обновление данных в родителе в этом случае будет передано и в дочерний компонент:

``` html
<div>
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
```

Зачастую проще использовать для `v-bind` сокращённую запись:

``` html
<child :my-message="parentMsg"></child>
```

Результат:

{% raw %}
<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Сообщение из родителя'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{myMessage}}</span>'
    }
  }
})
</script>
{% endraw %}

### Строковые и динамические параметры

Частой ошибкой новичков является попытка передать в качестве параметра компонента число, используя строковой синтаксис:

``` html
<!-- при такой записи в компонент будет передана строка "1" -->
<comp some-prop="1"></comp>
```

Однако, поскольку используется строковой параметр, в компонент вместо числа будет передано значение строки `"1"`. Для передачи числа нужно использовать директиву `v-bind`, так как её значение вычисляется как выражение JavaScript:

``` html
<!-- этот синтаксис позволит передать в компонент число -->
<comp v-bind:some-prop="1"></comp>
```

### Однонаправленный поток данных

Входные параметры создают **однонаправленный** поток данных между родительскими и дочерними компонентами: обновление свойств родителя будет передано в дочерний компонент, но обратное — не случится. Это предотвращает случайное изменение родительских данных дочерними компонентами, которое затруднило бы понимание потока данных приложения.

Кроме того, при любом обновлении родительского компонента все входные параметры дочерних компонентов также обновляются до нового значения. Поэтому **не стоит** изменять значения входных параметров внутри компонента и расчитывать на их сохранность. Если вы всё же захотите это сделать, Vue отреагирует предупреждением в консоли.

Желание изменить значение входного параметра обычно возникает в двух случаях:

1. Если он используется лишь для передачи изначального значения, после чего дочерний компонент хотел бы использовать эту переменную как локальную.

2. Если он передаётся как значение, требующее обработки.

Более правильным подходом в этих случаях будет:

1. Определение локальной переменной, использующей значение входного параметра для инициализации:

  ``` js
  props: ['initialCounter'],
  data: function () {
    return { counter: this.initialCounter }
  }
  ```

2. Определение вычисляемого свойства, основывающегося на значении входного параметра:

  ``` js
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

<p class="tip">Обратите внимание, что объекты и массивы в JavaScript передаются по ссылке, так что если входным параметром является объект или массив, его изменение внутри дочернего компонента **повлияет** на состояние родительского компонента.</p>

### Валидация входных параметров

Компонент может не только указать список ожидаемых параметров, но и предъявить к ним определённые требования. В случае, если переданные параметры не будут им удовлетворять, Vue отреагирует предупреждениями. Эта возможность особенно полезна при создании компонентов, для внешнего использования.

Вместо определения списка параметров как массива строк, можно использовать объект с правилами валидации:

``` js
Vue.component('example', {
  props: {
    // простая проверка типа (`null` означает допустимость любого типа)
    propA: Number,
    // несколько допустимых типов
    propB: [String, Number],
    // обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // значения по умолчанию для объектов/массивов должны
    // быть возвращаемыми значениями функций
    propE: {
      type: Object,
      default: function () {
        return { message: 'привет!' }
      }
    },
    // пользовательская функция для валидации
    propF: {
      validator: function (value) {
        return value > 10
      }
    }
  }
})
```

Параметр типа `type` должен принимать одно из нижеперечисленных нативных значений:

- String
- Number
- Boolean
- Function
- Object
- Array

Кроме того, `type` может быть и пользовательской функцией — проверка будет выполняться вызовом `instanceof`.

В случае ошибки валидации, Vue выбросит предупреждение в консоль (при использовании development-сборки).

## Пользовательские события

Мы узнали, что родитель может передавать данные в дочерние компоненты через входные параметры. Но как организовать связь в обратном направлении? Самое время поговорить о системе пользовательских событий Vue.

### Использование `v-on` с пользовательскими событиями

Каждый инстанс Vue поддерживает [интерфейс событий](../api/#Instance-Methods-Events), позволяющий:

- Отслеживать события, используя `$on(eventName)`
- Порождать события, используя `$emit(eventName)`

<p class="tip">Обратите внимание, что система событий Vue отделена от [EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget). Хотя они и похожи, `$on` и `$emit` __не являются__ псевдонимами для `addEventListener` и `dispatchEvent`.</p>

Кроме того, родительский компонент может зарегистрировать подписчика событий, используя директиву `v-on` непосредственно в шаблоне при создании дочернего компонента.

Вот пример:

``` html
<div id="counter-event-example">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
```

``` js
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})

new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
```

{% raw %}
<div id="counter-event-example" class="demo">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>
{% endraw %}

Важно отметить, что дочерний компонент остаётся полностью независимым от всего происходящего снаружи. Он всего лишь уведомляет внешний мир о происходящем с ним, на случай если родительскому компоненту это может быть интересно.

#### Подписка на нативные события в компонентах

Иногда может понадобиться подписаться на нативные события браузера в корневом элементе компонента. В таких случаях можно применить `v-on` с модификатором `.native`, например так:

``` html
<my-component v-on:click.native="doTheThing"></my-component>
```

### Поля ввода форм с использованием пользовательских событий

Пользуясь этой стратегией можно также создавать пользовательские поля ввода, использующие `v-model`. Вспомните, что

``` html
<input v-model="something">
```

это всего лишь синтаксический сахар для:

``` html
<input v-bind:value="something" v-on:input="something = $event.target.value">
```

При использовании с компонентом, запись упрощается до:

``` html
<custom-input v-bind:value="something" v-on:input="something = arguments[0]"></custom-input>
```

Таким образом, чтобы иметь возможность работать с `v-model`, компонент должен:

- принимать входной параметр `value`
- порождать событие `input` с новым значением

Давайте разберём в качестве примера простое поле ввода денежной суммы:

``` html
<currency-input v-model="price"></currency-input>
```

``` js
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    // Вместо обновления значения напрямую, этот метод используется для форматирования и
    // наложения ограничений на вводимое значение, а также порождает
    // событие, уведомляющее родительский компонент об изменениях
    updateValue: function (value) {
      var formattedValue = value
        // Удалить пробелы с обеих сторон
        .trim()
        // Сократить до 2 знаков после запятой
        .slice(0, value.indexOf('.') + 3)
      // Если значение не нормализовано — нормализуем вручную
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      // Порождаем событие с обновлённым значением поля ввода
      this.$emit('input', Number(formattedValue))
    }
  }
})
```

{% raw %}
<div id="currency-input-example" class="demo">
  <currency-input v-model="price"></currency-input>
</div>
<script>
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    updateValue: function (value) {
      var formattedValue = value
        .trim()
        .slice(0, value.indexOf('.') + 3)
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      this.$emit('input', Number(formattedValue))
    }
  }
})
new Vue({ el: '#currency-input-example' })
</script>
{% endraw %}

Реализация выше, конечно, остаётся довольно наивной. Например, она позволяет пользователям вводить несколько десятичных точек, и даже иногда буквы - упс! Для тех кто хотел бы увидеть менее тривиальный и более надёжный пример, то вот он:

<iframe width="100%" height="300" src="https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

Кроме того, этот интерфейс может быть использован не только для связи с полями ввода форм внутри компонентов, но и для создания более необычных полей воода. К примеру, представьте следующие возможности:

``` html
<voice-recognizer v-model="question"></voice-recognizer>
<webcam-gesture-reader v-model="gesture"></webcam-gesture-reader>
<webcam-retinal-scanner v-model="retinalImage"></webcam-retinal-scanner>
```

### Коммуникация вне случаев родитель-потомок

Иногда компонентам необходимо обмениваться информацией, но они не состоят в отношении родитель/потомок. В простых случаях может хватить использования пустого инстанса Vue в качестве централизованной шины данных:

``` js
var bus = new Vue()
```
``` js
// в методе компонента A
bus.$emit('id-selected', 1)
```
``` js
// в обработчике created компонента B
bus.$on('id-selected', function (id) {
  // ...
})
```

Для более сложных случаев стоит рассмотреть использование специализированного [паттерна управления состоянием](state-management.html).

## Дистрибьюция контента через слоты

Нередко хочется вкладывать компоненты друг в друга следующим образом:

``` html
<app>
  <app-header></app-header>
  <app-footer></app-footer>
</app>
```

Здесь стоит обратить внимание на две вещи:

1. Компонент `<app>` не знает, какой контент он будет содержать после монтирования. Решение принимается каким-либо родителем, использующим `<app>`.

2. Скорее всего у компонента `<app>` есть собственный шаблон.

Чтобы такая композиция работала, необходим метод "переплетения" шаблона компонента и внутреннего содержимого, указанного при его использовании в родительском контексте. Этот процесс называется **дистрибьюцией контента** (или, в терминах Angular — "включением"("transclusion")). Vue.js реализует API дистрибьюции контента, смоделированный в соответствии с текущим [черновиком спецификации Web Components](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) использующее специальный элемент `<slot>`, служащий "точкой выхода" для оригинального контента.

### Область видимости при компиляции

Перед тем как углубиться в рассмотрение API слотов, давайте сперва разберёмся, в какой области видимости компилируется содержимое шаблонов. Представим такой шаблон:

``` html
<child-component>
  {{ message }}
</child-component>
```

Из родительского, или из дочернего контекста должна быть взята переменная `message`? Правильный ответ — из родительского. Действует простое правило:

> Всё в шаблоне родителя компилируется в области видимости родителя; всё в шаблоне дочернего компонента — в его области видимости.

Распространённой ошибкой является попытка связывания со свойством дочернего компонента в родительском шаблоне:

``` html
<!-- НЕ сработает -->
<child-component v-show="someChildProperty"></child-component>
```

Если `someChildProperty` является свойством дочернего компонента, вышеприведённый пример работать не будет. Шаблон родительского компонента не имеет никакого представления о состоянии дочернего компонента.

При необходимости привязать директивы из области видимости дочернего компонента к корневому элементу, это необходимо сделать в его же шаблоне:

``` js
Vue.component('child-component', {
  // а так — уже сработает, так как мы находимся в правильной области видимости
  template: '<div v-show="someChildProperty">Child</div>',
  data: function () {
    return {
      someChildProperty: true
    }
  }
})
```

Аналогично, распределяемый контент будет также компилироваться в родительской области видимости.

### Вариант с единственным слотом

Родительский контент будет **отброшен**, если в шаблоне дочернего компонента не будет содержаться хотя бы один элемент `<slot>`. В случае, если слот всего один, и не содержит атрибутов, всё содержимое родительского элемента будет помещено в DOM на этой позиции, замещая собой сам слот.

Изначальное содержимое тега `<slot>` считается **резервным контентом**. Оно компилируется в области видимости дочернего элемента и отображается только в том случае, когда родительский элемент пуст.

Предположим, у нас есть компонент `my-component`, с таким шаблоном:

``` html
<div>
  <h2>Я — заголовок дочернего компонента</h2>
  <slot>
    Этот текст будет отображён только если
    не будет передано контента для дистрибьюции.
  </slot>
</div>
```

И родитель, использующий этот компонент:

``` html
<div>
  <h1>Я — заголовок родителя</h1>
  <my-component>
    <p>Немного оригинального контента</p>
    <p>И ещё немного</p>
  </my-component>
</div>
```

Результатом рендера будет:

``` html
<div>
  <h1>Я — заголовок родителя</h1>
  <div>
    <h2>Я — заголовок дочернего компонента</h2>
    <p>Немного оригинального контента</p>
    <p>И ещё немного</p>
  </div>
</div>
```

### Именованные слоты

Для элементов `<slot>` можно указать специальный атрибут `name`, который используется для ещё более гибкой дистрибьюции контента. Можно создать несколько слотов с различными именами. Именованный слот получит весь контент, помеченный соответствующим значением атрибута `slot`.

Один из слотов можно оставить безымянным, что сделает его **слотом по умолчанию**, в который попадёт весь контент, для которого имя слота не указано. В случае отсутствия безымянного слота, такой контент будет попросту отброшен.

Например, предположим что у нас есть компонент `app-layout` с таким шаблоном:

``` html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

Шаблон родителя:

``` html
<app-layout>
  <h1 slot="header">Здесь мог бы быть заголовок страницы</h1>

  <p>Абзац основного контента.</p>
  <p>И ещё один.</p>

  <p slot="footer">Здесь — контактная информация</p>
</app-layout>
```

Результатом рендера будет:

``` html
<div class="container">
  <header>
    <h1>Здесь мог бы быть заголовок страницы</h1>
  </header>
  <main>
    <p>Абзац основного контента.</p>
    <p>И ещё один.</p>
  </main>
  <footer>
    <p>Здесь — контактная информация</p>
  </footer>
</div>
```

API дистрибьюции контента оказывается очень полезным механизмом для создания компонентов, задуманных для совместного использования.

### Слоты с ограниченной областью видимости

> Добавлены в 2.1.0

Слот с ограниченной областью видимости — это особый тип слота, который можно использовать в качестве повторно используемого шаблона (в который можно передать данные) вместо уже отрендеренных элементов.

В дочернем компоненте, просто передайте данные в слот, как если бы вы передавали входные параметры в компонент:

``` html
<div class="child">
  <slot text="hello from child"></slot>
</div>
```

В родителе, элемент `<template>` с особым атрибутом `scope` указывает, что это шаблон для именованного слота. Значение `scope` — это имя временной переменной, содержащей входные параметры, переданные от потомка:

``` html
<div class="parent">
  <child>
    <template scope="props">
      <span>hello from parent</span>
      <span>{{ props.text }}</span>
    </template>
  </child>
</div>
```

Результатом рендера кода выше будет:

``` html
<div class="parent">
  <div class="child">
    <span>hello from parent</span>
    <span>hello from child</span>
  </div>
</div>
```

Более типичным случаем для использования слотов с ограниченной областью видимости является компонент списка, позволяющий клиенту настроить отображение своих элементов:

``` html
<my-awesome-list :items="items">
  <!-- слот с ограниченной областью видимости может быть и именованным -->
  <template slot="item" scope="props">
    <li class="my-fancy-item">{{ props.text }}</li>
  </template>
</my-awesome-list>
```

И шаблон для компонента списка:

``` html
<ul>
  <slot name="item"
    v-for="item in items"
    :text="item.text">
    <!-- здесь — контент для резервного отображения -->
  </slot>
</ul>
```

## Динамическое переключение компонентов

Существует возможность динамического переключения между различными компонентами, в единой точке монтирования. Для этого используется псевдоэлемент `<component>` и динамическое связывание его атрибута `is`:


``` js
var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
```

``` html
<component v-bind:is="currentView">
  <!-- изменения vm.currentView поменяют отображаемый компонент! -->
</component>
```

При желании можно связываться с объектами компонентов и напрямую:

``` js
var Home = {
  template: '<p>Добро пожаловать домой!</p>'
}

var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})
```

### `keep-alive`

Если вы хотите сохранять временно отключенные компоненты в памяти, чтобы не терять их состояния и избежать повторного рендера, можно завернуть динамический компонент в псевдоэлемент `<keep-alive>`:

``` html
<keep-alive>
  <component :is="currentView">
    <!-- неактивные компоненты будут закешированы! -->
  </component>
</keep-alive>
```

Более детально `<keep-alive>` рассмотрен в [справочнике по API](../api/#keep-alive).

## Разное

### Создание компонентов для повторного использования

Создавая компоненты, неплохо понимать, собираетесь ли вы использовать их где-то ещё в будущем. Для одноразовых компонентов нормально быть и сильно связанными. Но вот компонентам, предназначенным для повторного использования обязательно необходим ясный публичный интерфейс, не делающий излишних предположений о контексте использования компонента.

API компонентов Vue состоит из трёх частей: входных параметров, событий и слотов:

- **Входные параметры** позволяют передавать в компонент данные извне.

- **События** позволяют компонентам инициировать побочные эффекты во внешнем окружении.

- **Слоты** позволяют внешнему окружению создавать композицию компонентов с дополнительным контентом.

С использованием специального сокращённого синтаксиса `v-bind` и `v-on`, намерения можно явно выразить в шаблоне:

``` html
<my-component
  :foo="baz"
  :bar="qux"
  @event-a="doThis"
  @event-b="doThat"
>
  <img slot="icon" src="...">
  <p slot="main-text">Привет!</p>
</my-component>
```

### Ссылки на дочерние компоненты

Несмотря на наличие входных параметров и событий, иногда всё же возникает необходимость обратиться к дочерним компонентам в JavaScript напрямую. Для этих целей можно назначить ссылку на дочерний компонент при помощи атрибута `ref`. Например:

``` html
<div id="parent">
  <user-profile ref="profile"></user-profile>
</div>
```

``` js
var parent = new Vue({ el: '#parent' })
// получаем инстанс дочернего компонента
var child = parent.$refs.profile
```

Если `ref` используется вместе с директивой `v-for`, будет создан массив или объект со ссылками на инстансы, структурно повторяющий исходные данные.

<p class="tip">Объект `$refs` заполняется только после рендера компонента и не является реактивным. Следует избегать использования `$refs` в шаблонах и вычисляемых свойствах, рассматривая его только как крайнее средство для манипуляций напрямую.</p>

### Асинхронные компоненты

В крупных приложениях может возникнуть необходимость в разделении приложения на небольшие куски и подгружать компонент с сервера, только когда он необходим. Для упрощения подобных сценариев, Vue позволяет определить компонент как функцию-фабрику, асинхронно возвращающую определение компонента. Vue вызовет фабричную функцию только тогда, когда компонент действительно понадобится, и закеширует результат для дальнейшего использования. Например:

``` js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Передаем шаблон компонента в функцию обратного вызова resolve
    resolve({
      template: '<div>Я — асинхронный!</div>'
    })
  }, 1000)
})
```

Функция-фабрика получает параметр `resolve` — функцию обратного вызова, которую следует вызывать после получения компонента от сервера. Кроме того, можно вызвать `reject(reason)`, если загрузка по какой-либо причине не удалась. Мы используем `setTimeout` исключительно в демонстрационных целях; как именно получать компонент в реальной ситуации — решать только вам самим. Одним из рекомендованных подходов будет использование асинхронных компонентов в связке с [возможностями Webpack'а по разделению кода](http://webpack.github.io/docs/code-splitting.html):

``` js
Vue.component('async-webpack-example', function (resolve) {
  // специальный синтаксис require укажет Webpack
  // автоматически разделить сборку на части
  // для последующей асинхронной загрузки
  require(['./my-async-component'], resolve)
})
```

В функции resolve можно также вернуть промис, так что используя Webpack 2 и синтаксис ES2015 можно сделать так:

``` js
Vue.component(
  'async-webpack-example',
  () => System.import('./my-async-component')
)
```

<p class="tip">Если вы используете <strong>Browserify</strong> и тоже хотите использовать асинхронные компоненты, нам, к сожалению, придётся вас огорчить: это невозможно, и вряд ли будет возможно когда-либо, так как сам создатель Browserify [прояснил](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224), что асинхронная загрузка "не является чем-то, что Browserify когда-либо будет поддерживать." По крайней мере, такова официальная позиция. Сообщество Browserify обнаружило возможные [обходные пути](https://github.com/vuejs/vuejs.org/issues/620), что может помочь уже существующим сложным приложениям. Но в целом мы советуем использовать Webpack, обладающий полноценной встроенной поддержкой асинхронной загрузки частей сборки.</p>

### Соглашения по именованию компонентов

При регистрации компонентов (или входных параметров), вы можете использовать kebab-case, camelCase или TitleCase. Vue — без разницы.

``` js
// при определении компонента
components: {
  // регистрация с использованием kebab-case
  'kebab-cased-component': { /* ... */ },
  // регистрация с использованием camelCase
  'camelCasedComponent': { /* ... */ },
  // регистрация с использованием TitleCase
  'TitleCasedComponent': { /* ... */ }
}
```

В HTML-шаблонах, однако, придётся использовать эквивалентный kebab-case:

``` html
<!-- всегда используйте kebab-case в HTML-шаблонах -->
<kebab-cased-component></kebab-cased-component>
<camel-cased-component></camel-cased-component>
<title-cased-component></title-cased-component>
```

Однако, при использовании _строковых_ шаблонов, мы уже не связаны ограничениями регистронезависимости HTML. Это значит, что даже в шаблоне вы можете указывать компоненты и входные параметры как в camelCase, так и в TitleCase или kebab-case:

``` html
<!-- в строковых шаблонах вы вольны использовать любой подход! -->
<my-component></my-component>
<myComponent></myComponent>
<MyComponent></MyComponent>
```

Если компонент не содержит слотов, его можно даже сделать самозакрывающимся, указав `/` после имени:

``` html
<my-component/>
```

Ещё раз заметим, что это возможно _только_ при использовании строковых шаблонов, поскольку самозакрывающие пользовательские элементы не являются валидными в HTML, и нативные парсеры браузеров такую запись не поймут.

### Рекурсивные компоненты

Компоненты могут рекурсивно вызывать самих себя в своих шаблонах. Однако, эта возможность доступна только при указании опции `name`:

``` js
name: 'unique-name-of-my-component'
```

При глобальной регистрации, глобальный ID автоматически присваивается и опции `name` компонента:

``` js
Vue.component('unique-name-of-my-component', {
  // ...
})
```

Если не соблюдать осторожность, рекурсивные компоненты могут привести к появлению бесконечных циклов:

``` js
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
```

Компонент, подобный вышеописанному, породит ошибку переполнения стека, поэтому обязательно удостоверьтесь, что рекурсивный вызов является условным (т.е. использует директиву `v-if`, которая рано или поздно станет ложной).

### Кольцевые ссылки между компонентами

Предположим вы конструируете каталог файлов в виде дерева, подобный Finder или Проводнику. У вас возможно есть компонент `tree-folder` с таким шаблоном:

``` html
<p>
  <span>{{ folder.name }}</span>
  <tree-folder-contents :children="folder.children"/>
</p>
```

Затем компонент `tree-folder-contents` с таким шаблоном:

``` html
<ul>
  <li v-for="child in children">
    <tree-folder v-if="child.children" :folder="child"/>
    <span v-else>{{ child.name }}</span>
  </li>
</ul>
```

Рассмотрев данный пример более тщательно, вы увидите, что эти компоненты при рендере окажутся потомком _и_ предком друг друга - парадокс! При глобальной регистрации компонентов с использованием `Vue.component`, данный парадокс будет разрешен для вас автоматически. Если это ваш случай, то можете дальше не читать.

Тем не менее, если вы импортируете компоненты используя __модульный сборщик__, такой как Webpack или Browserify, вы получите ошибку.

```
Failed to mount component: template or render function not defined.
```

Для объяснения того, что произошло давайте назовем наши компоненты A и B. Модульный сборщик видит, что ему нужен A, но A сперва нужен B, но B нужен A, и т.д. Сборщик застревает в цикле, не зная как разрешить оба компонента. Чтобы это исправить, нам понадобится дать сборщику точку в которой он сможет сказать: "_В конце концов_ A нужен B, но нет необходимости сперва разрешать B."

Для нашего случая, мы сделаем такой точкой компонент `tree-folder`. Мы знаем, что дочерний компонент, создающий парадокс - это `tree-folder-contents`, таким образом подождем до события `beforeCreate` цикла жизни компонента, чтобы зарегистрировать его.

``` js
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
}
```

Проблема решена!

### Inline-шаблоны

При указании специального атрибута `inline-template` на дочернем компоненте, содержимое элемента будет использовано не для дистрибьюции контента, а в качестве шаблона этого компонента. Это делает использование шаблонов более гибким.

``` html
<my-component inline-template>
  <div>
    <p>Этот шаблон будет скомпилирован в области видимости дочернего компонента.</p>
    <p>Доступа к данным родителя — нет.</p>
  </div>
</my-component>
```

Однако, использование `inline-template` затрудняет понимание происходящего в шаблонах. Как хорошую практику, предпочитайте определение шаблонов внутри компонента с использованием опции `template` или в элементе `template` `.vue`-файла.

### Определение шаблонов через X-Template

Другой возможностью определения шаблонов является использование специальных элементов `script` с указанием типа `text/x-template` и id, на который можно сослаться при регистрации шаблона. Например:

``` html
<script type="text/x-template" id="hello-world-template">
  <p>Привет привет привет</p>
</script>
```

``` js
Vue.component('hello-world', {
  template: '#hello-world-template'
})
```

Эта возможность может оказаться полезной для демо с большими шаблонами, или в очень маленьких приложениях, но в целом этого подхода следует избегать из-за разнесения шаблонов и остальных частей определения компонентов.

### "Дешёвые" статические компоненты с использованием `v-once`

Рендер простых элементов HTML во Vue происходит очень быстро, но иногда возникают компоненты с **большим** количеством статических данных. В таких случаях добавление директивы `v-once` в корневом элементе позволяет удостовериться, что все вычисления будут произведены лишь единожды, а дальнейшая работа будет происходить с кешем, например таким образом:

``` js
Vue.component('terms-of-service', {
  template: '\
    <div v-once>\
      <h1>Условия Использования</h1>\
      ... много-много статического контента ...\
    </div>\
  '
})
```
