---
title: API
type: api
---

## Глобальные параметры

`Vue.config` — это объект, содержащий глобальные параметры Vue. Перед загрузкой приложения можно изменить следующие свойства:

### silent

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Использование:**

  ``` js
  Vue.config.silent = true
  ```

  Отключает вывод логов и предупреждений Vue.

### optionMergeStrategies

- **Тип:** `{ [key: string]: Function }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Меняет стратегию слияния опций на вашу собственную.

  Стратегия слияния получает значения опции родительского и дочернего элемента первым и вторым параметром соответственно.
  Третьим параметром передаётся контекст действующего экземпляра Vue.

- **См. также:** [Пользовательские стратегии слияния опций](../guide/mixins.html#Пользовательские-стратегии-слияния-опций)

### devtools

- **Тип:** `boolean`

- **По умолчанию:** `true` (`false` в production-сборках)

- **Использование:**

  ``` js
  // убедитесь, что устанавливаете это свойство синхронно сразу после загрузки Vue
  Vue.config.devtools = true
  ```

  Указывает, должен ли Vue позволять [Vue-devtools](https://github.com/vuejs/vue-devtools) проводить инспекцию. Значение по умолчанию для development-окружения — `true`, для production-сборок — `false`. Установите `true`, чтобы vue-devtools работал и в production.

### errorHandler

- **Тип:** `Function`

- **По умолчанию:** Ошибка выбрасывается "на месте"

- **Использование:**

  ``` js
  Vue.config.errorHandler = function (err, vm) {
    // обработка ошибки
  }
  ```

  Устанавливает обработчик для ошибок, не пойманных во время рендеринга компонентов и в наблюдателях. Обработчик получит в параметрах ошибку и действующий экземпляр Vue.

  > Сервис отслеживания ошибок [Sentry](https://sentry.io) предлагает [официальную интеграцию](https://sentry.io/for/vue/) с использованием этого свойства.

### ignoredElements

- **Тип:** `Array<string>`

- **По умолчанию:** `[]`

- **Использование:**

  ``` js
  Vue.config.ignoredElements = [
    'my-custom-web-component', 'another-web-component'
  ]
  ```

  Позволяет Vue игнорировать пользовательские компоненты, установленные за пределами Vue (например, используя Web Components API). Иначе возникнет предупреждение о "Неизвестном пользовательском элементе", означающее, что вы забыли зарегистрировать глобальный компонент или допустили ошибку в написании имени компонента.

### keyCodes

- **Тип:** `{ [key: string]: number | Array<number> }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    mediaPlayPause: 179,
    up: [38, 87]
  }
  ```

  Определение пользовательских псевдонимов для директивы `v-on`.

## Глобальный API

<h3 id="Vue-extend">Vue.extend( options )</h3>

- **Аргументы:**
  - `{Object} options`

- **Использование:**

  Создаёт "подкласс" базового конструктора Vue. Принимает параметром объект с опциями нового компонента.

  Внимание: у объекта, переданного в `Vue.extend()` свойство `data` должно быть функцией.

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // Создание конструктора
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}}, также известный как {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Уолтер',
        lastName: 'Уайт',
        alias: 'Гейзенберг'
      }
    }
  })
  // создаёт экземпляр Profile и монтирует его к элементу DOM
  new Profile().$mount('#mount-point')
  ```

  Результатом будет:

  ``` html
  <p>Уолтер Уайт, также известный как Гейзенберг</p>
  ```

- **См. также:** [Компоненты](../guide/components.html)

<h3 id="Vue-nextTick">Vue.nextTick( [callback, context] )</h3>

- **Аргументы:**
  - `{Function} [callback]`
  - `{Object} [context]`

- **Использование:**

  Выполняет функцию `callback` при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM.

  ``` js
  // изменение данных
  vm.msg = 'Привет'
  // DOM ещё не обновлён
  Vue.nextTick(function () {
    // теперь DOM обновлён
  })
  ```

  > Добавлено в версии 2.1.0: возвращает `Promise`, если окружение их поддерживает и коллбэк не указан.

- **См. также:** [Асинхронная очередь обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)


<h3 id="Vue-set">Vue.set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  Меняет значение поля. Если объект реактивный, поле тоже станет реактивным, а шаблон обновится. Обычно нужен, потому что Vue не может среагировать на неявное добавление полей.

  **Обратите внимание что объект не может быть экземпляром Vue или корневым объектом data экземпляра Vue.**

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

<h3 id="Vue-delete">Vue.delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  Удаляет поле. Если объект реактивный, шаблон обновится. Обычно нужен, потому что Vue не может среагировать на неявное удаление полей (но вам редко когда это понадобится).

  **Обратите внимание что объект не может быть экземпляром Vue или корневым объектом data экземпляра Vue.**

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новую глобальную директиву или возвращает уже зарегистрированную.

  ``` js
  // регистрируем директиву-объект:
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // региструем директиву в виде простой функции:
  Vue.directive('my-directive', function () {
    // Vue будет вызывать эту функцию как `bind` и `update`
  })

  // получаем определение директивы, если она зарегистрирована:
  var myDirective = Vue.directive('my-directive')
  ```

- **См. также:** [Пользовательские директивы](../guide/custom-directive.html)

<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function} [definition]`

- **Использование:**

  Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.

  ``` js
  // регистрируем фильтр:
  Vue.filter('my-filter', function (value) {
    // возвращаем обработанное значение
  })

  // получаем фильтр, если он зарегистрирован:
  var myFilter = Vue.filter('my-filter')
  ```

<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новый глобальный компонент или возвращает уже зарегистрированный. Регистрация также автоматически установит свойство `name` компонента равным переданному `id`.

  ``` js
  // регистрируем конструктор, полученный из Vue.extend:
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // регистрируем объект с опциями (Vue вызовет для этого объекта Vue.extend автоматически):
  Vue.component('my-component', { /* ... */ })

  // получаем зарегистрированный компонент (всегда вернёт конструктор):
  var MyComponent = Vue.component('my-component')
  ```

- **См. также:** [Компоненты](../guide/components.html)

<h3 id="Vue-use">Vue.use( plugin )</h3>

- **Аргументы:**
  - `{Object | Function} plugin`

- **Использование:**

  Устанавливает плагин Vue.js. Если плагин — объект, у него должен быть публичный метод `install`. Если плагин — функция, она будет воспринята как метод `install`. Этот метод будет выполнен с Vue в качестве аргумента.

  Плагин будет установлен только один раз, независимо от количества вызовов этого метода с одним и тем же плагином.

- **См. также:** [Плагины](../guide/plugins.html)

<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

- **Аргументы:**
  - `{Object} mixin`

- **Использование:**

  Применяет примесь ко всем созданным впоследствии экземплярам Vue. Так авторы плагинов могут встроить желаемое поведение в компоненты. **Не рекомендуется использовать в коде приложений**.

- **См. также:** [Глобальные примеси](../guide/mixins.html#Глобальные-примеси)

<h3 id="Vue-compile">Vue.compile( template )</h3>

- **Аргументы:**
  - `{string} template`

- **Использование:**

  Компилирует строковый шаблон в `render`-функцию. **Доступен только в standalone-сборке.**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **См. также:** [Render-функции](../guide/render-function.html)

## Опции — данные

### data

- **Тип:** `Object | Function`

- **Ограничение:** При создании компонента, может быть только типа `Function`.

- **Подробности:**

  Объект с данными экземпляра Vue. Vue рекурсивно переводит его поля в геттеры/сеттеры, и он становится "реактивным". **Объект должен быть простым**: Vue проигнорирует свойства прототипа и нативные объекты, как например из API браузера. Прежде всего, рекомендуем чтобы данные были просто данными — не стоит передавать сюда объекты с собственным управлением внутренним состоянием.

  Добавлять реактивные свойства к корневому объекту данных после его инициализации нельзя. Поэтому определяйте корневые реактивные свойства до создания экземпляра.

  После создания экземпляра, объект с данными доступен в `vm.$data`. Кроме того, экземпляр Vue проксирует обнаруженные в нём свойства, так что `vm.a` эквивалентно `vm.$data.a`.

  Свойства, названия которых начинается с `_` или `$` **не проксируются** из-за возможных конфликтов со внутренними свойствами и методами API Vue. Доступ к таким свойствам возможен только через `vm.$data._property`.

  Для определения **компонента** опция `data` должна быть функцией, возвращающей объект для инициализации, потому что из одного определения компонента может быть создано несколько экземпляров. Если бы мы использовали для `data` простой объект, все созданные экземпляры получили бы **ссылку на него**! А когда `data` — функция, при создании нового экземпляра можно вызвать её и получить свежую копию данных для инициализации.

  Чтобы получить полную копию оригинального объекта, передайте `vm.$data` в `JSON.parse(JSON.stringify(...))`.

- **Пример:**

  ``` js
  var data = { a: 1 }

  // создаём экземпляр напрямую:
  var vm = new Vue({
    data: data
  })
  vm.a // -> 1
  vm.$data === data // -> true

  // обязательно используйте функцию во Vue.extend():
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции в параметре `data`__ (напр. `data: () => { return { a: this.myProp }}`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue и `this.myProp` окажется неопределённым.</p>

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

### props

- **Тип:** `Array<string> | Object`

- **Подробности:**

  Список или хэш атрибутов, по которым разрешено получение данных от родительского компонента. Передайте простой массив названий или объект, задающий дополнительные параметры, например типы, правила валидации и значения по умолчанию.

- **Пример:**

  ``` js
  // простая форма записи:
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // объект с указанием правил валидации:
  Vue.component('props-demo-advanced', {
    props: {
      // только проверка типа
      height: Number,
      // проверка типа и другие правила валидации
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **См. также:** [Входные параметры](../guide/components.html#Входные-параметры)

### propsData

- **Тип:** `{ [key: string]: any }`

- **Ограничение:** учитывается только при создании экземпляра выражением `new`.

- **Подробности:**

  Параметры компонента при его создании. Обычно используются для облегчения модульного тестирования.

- **Пример:**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'привет'
    }
  })
  ```

### computed

- **Тип:** `{ [key: string]: Function | { get: Function, set: Function, cache: Boolean } }`

- **Подробности:**

  Вычисляемые свойства, которые будут подмешаны к экземпляру Vue. В геттерах и сеттерах `this` будет указывать на экземпляр Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции при определении вычисляемых свойств__ (напр. `aDouble: () => this.a * 2`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.a` окажется неопределённым.</p>

  Вычисляемые свойства кешируются и повторно вычисляются только при изменении реактивных зависимостей. Обратите внимание, что если определённая зависимость выходит за область видимости экземпляра (т.е не реактивная), то вычисляемое свойство не будет обновляться. В этой ситуации кеширование можно отключить с помощью опции `cache: false`. Тем не менее, так как зависимость не реактивная, её изменение не будет вызывать обновление DOM.

  В большинстве ситуаций `cache: false` не станет идеальным решением. По возможности лучше переносить внешние данные в систему реактивности. Например, если вычисляемое свойство зависит от размера окна, вы можете хранить эту информацию в `data`, а затем использовать событие `resize` чтобы поддерживать значение актуальным. Теперь данные реактивны!

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // если свойство только возвращает данные, достаточно простой функции:
      aDouble: function () {
        return this.a * 2
      },
      // свойство и возвращает, и получает данные:
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // -> 2
  vm.aPlus = 3
  vm.a       // -> 2
  vm.aDouble // -> 4
  ```

- **См. также:**
  - [Вычисляемые свойства](../guide/computed.html)

### methods

- **Тип:** `{ [key: string]: Function }`

- **Подробности:**

  Методы, которые будут подмешаны к экземпляру Vue. Вы можете запустить эти методы прямо из экземпляра VM, или использовать их в директивах. `this` методов указывает на экземпляр Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции при определении методов__ (напр. `plus: () => this.a++`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.a` окажется неопределённым.</p>

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **См. также:** [Обработка событий](../guide/events.html)

### watch

- **Тип:** `{ [key: string]: string | Function | Object }`

- **Подробности:**

  Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут строками с именами методов, или объектами, содержащими дополнительные опции. Экземпляр Vue вызовет `$watch()` соответствующий каждому ключу объекта при своём создании.

- **Пример:**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3
    },
    watch: {
      a: function (val, oldVal) {
        console.log('новое значение: %s, старое значение: %s', val, oldVal)
      },
      // строка с именем метода:
      b: 'someMethod',
      // глубокий (рекурсивный) наблюдатель:
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      }
    }
  })
  vm.a = 2 // -> новое значение: 2, старое значение: 1
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать стрелочные функции при определении наблюдателей__ (напр. `searchQuery: newValue => this.updateAutocomplete(newValue)`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.updateAutocomplete` окажется неопределённым.</p>

- **См. также:** [Методы экземпляра — vm.$watch](#vm-watch)

## Опции — DOM

### el

- **Тип:** `string | HTMLElement`

- **Ограничение:** учитывается только при создании экземпляра выражением `new`.

- **Подробности:**

  Указывает, на какой существующий DOM-элемент смонтировать экземпляр Vue. Может быть строковым CSS-селектором или собственно объектом типа HTMLElement.

  После монтирования экземпляра, переданный или найденный по CSS-селектору элемент будет доступен в `vm.$el`.

  Если эта опция указана при создании экземпляра, компиляция начнётся сразу же. В остальных случаях, вызовите `vm.$mount()`, чтобы запустить компиляцию.

  <p class="tip">Указанный элемент служит только точкой монтирования. В отличии от Vue 1.x, он обязательно будет заменён DOM-ом, сгенерированным Vue. Поэтому не стоит монтировать в корневые элементы `<html>` или `<body>`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### template

- **Тип:** `string`

- **Подробности:**

  Строковый шаблон с разметкой для экземпляра Vue. Этот шаблон **заменит** элемент в точке монтирования. Вся уже существующая разметка в точке монтирования будет проигнорирована, если в шаблоне нет слота распределения контента.

  Если строка начинается с `#`, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Так вы сможете включать шаблоны, из тегов вроде `<script type="x-template">`.

  <p class="tip">С точки зрения безопасности необходимо использовать только те шаблоны Vue, которым вы можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.</p>

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)

### render

  - **Тип:** `Function`

  - **Подробности:**

    Альтернатива строковым шаблонам, позволяющая задействовать все алгоритмические возможности JavaScript. `Render`-функция получает первым аргументом метод `createElement`, нужный для создания `VNode`-ов.

    Если компонент функциональный, вторым параметром передаётся `context`, дающий доступ к контекстным данным, так как функциональные компоненты не имеют экземпляров.

  - **См. также:**
    - [Render-функции](../guide/render-function.html)

## Опции — хуки жизненного цикла

Хук (hook — буквально "крючок"), функция, вызывающаяся в определённый момент жизненного цикла сущности, например, непосредственно перед или после создания компонента Vue. Хук позволяет расширить или изменить стандартное поведение на пользовательское.

Контекст `this` хуков указывает на экземпляр Vue c данными, вычисляемыми свойствами и методами. Это значит, что __вам не следует использовать стрелочные функции для определения хуков жизненного цикла__ (напр. `created: () => this.fetchTodos()`). Поскольку стрелочные функции связываются с родительским контекстом, `this` не будет указывать на экземпляр Vue, и `this.fetchTodos` окажется неопределённым.

### beforeCreate

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после инициализации экземпляра, до настройки наблюдения за данными, механизмов слежения и событий.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### created

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после создания экземпляра. На этом этапе экземпляр закончил обработку опций и настроил наблюдение за данными, вычисляемые свойства, методы, коллбэки слежения и событий. Однако, фаза монтирования ещё не начата, и свойство `$el` ещё не доступно.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeMount

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед началом монтирования, сразу перед первым вызовом функции `render`.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### mounted

- **Тип:** `Function`

- **Подробности:**

  Вызывается сразу после того как экземпляр был смонтирован, а взамен `el` создан `vm.$el`. Если корневой экземпляр смонтирован на элемент документа, `vm.$el` тоже будет элементом документа.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeUpdate

- **Тип:** `Function`

- **Подробности:**

  Вызывается при изменении данных, до повторного рендеринга и обновления виртуального DOM-а.

  В этом хуке можно дополнительно изменять состояние, и это не вызовет нового повторного рендеринга.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### updated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после того, как виртуальный DOM был обновлён из-за изменения данных.

  DOM компонента уже будет обновлён к моменту вызова этого хука, поэтому можно выполнять зависящие от DOM операции. Старайтесь избегать изменения состояния в этом хуке, чтобы не попасть в бесконечный цикл обновления.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### activated

- **Тип:** `Function`

- **Подробности:**

  Вызывается при активации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### deactivated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после деактивации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### beforeDestroy

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед уничтожением экземпляра Vue. На этом этапе экземпляр всё ещё полностью функционален.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### destroyed

- **Тип:** `Function`

- **Подробности:**

  Вызывается после уничтожения экземпляра Vue. К моменту вызова этого хука, все директивы экземпляра Vue уже отвязаны, все подписчики событий удалены, а все дочерние экземпляры Vue уничтожены.

  **При рендеринге на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Опции — ресурсы

### directives

- **Тип:** `Object`

- **Подробности:**

  Хэш директив, доступных экземпляру Vue.

- **См. также:**
  - [Пользовательские директивы](../guide/custom-directive.html)
  - [Соглашение по именованию компонентов](../guide/components.html#Соглашения-по-именованию-компонентов)

### filters

- **Тип:** `Object`

- **Подробности:**

  Хэш фильтров, доступных экземпляру Vue.

- **См. также:**
  - [`Vue.filter`](#Vue-filter)

### components

- **Тип:** `Object`

- **Подробности:**

  Хэш компонентов, доступных экземпляру Vue.

- **См. также:**
  - [Компоненты](../guide/components.html)

## Опции — разное

### parent

- **Тип:** `экземпляр Vue`

- **Подробности:**

  Определяет родительский экземпляр для создаваемого. Устанавливает отношение "родитель-потомок" между ними. Родитель будет доступен дочернему экземпляру посредством `this.$parent`, а дочерний экземпляр будет добавлен в массив `$children` родителя.

  <p class="tip">Старайтесь реже использовать `$parent` и `$children` — этот механизм мы предусмотрели на крайний случай. Для общения между родителем и ребёнком лучше использовать свойства и события.</p>

### mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Массив объектов-примесей. Примеси могут содержать те же опции, что и обычные объекты экземпляров Vue — они будут добавлены к основным опциям согласно логике `Vue.extend()`. Например, если и примесь и объект экземпляра содержат хук `created`, то будут вызваны оба.

  Хуки примесей вызываются в порядке их определения, до вызова собственных хуков компонента.

- **Пример:**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // -> 1
  // -> 2
  ```

- **См. также:** [Примеси](../guide/mixins.html)

### name

- **Тип:** `string`

- **Ограничение:** учитывается только при определении компонента.

- **Подробности:**

  Название компонента. Позволяет компоненту рекурсивно вызывать самого себя в шаблоне. Обратите внимание что когда компонент регистрируется глобально посредством `Vue.component()`, глобальный ID автоматически устанавливается равным его имени.

  Кроме того, компоненты с указанным `name` проще отлаживать из-за более понятных сообщений в консоли. В [Vue-devtools](https://github.com/vuejs/vue-devtools) все безымянные компоненты довольно неинформативно называются `<AnonymousComponent>`. Указание имён для компонентов значительно улучшает ситуацию.

### extends

- **Тип:** `Object | Function`

- **Подробности:**

  Позволяет декларативно наследоваться от другого компонента (который может быть либо простым объектом, либо конструктором), не используя `Vue.extend`. Главным образом предназначено для облегчения наследования между компонентами, определёнными в одном файле.

  Эта функциональность близка к `mixins`, с той разницей, что собственные опции компонента приоритетнее опций компонента, от которого происходит наследование.

- **Пример:**

  ``` js
  var CompA = { ... }

  // наследуем от CompA, не вызывая Vue.extend:
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### delimiters

- **Тип:** `Array<string>`

- **По умолчанию:** `{% raw %}["{{", "}}"]{% endraw %}`

- **Подробности:**

  Разделители, выделяющие текст для интерполяции. **Доступно только в standalone-сборке.**

- **Пример:**

  ``` js
  new Vue({
    delimiters: ['${', '}']
  })

  // Разделители изменены на стиль строк-шаблонов в ES6
  ```

### functional

- **Тип:** `boolean`

- **Подробности:**

  Превращает компонент в функциональный, то есть не имеющий собственного состояния (`data`) и своего экземпляра (`this`). Такие компоненты по сути — просто `render`-функция, возвращающая узлы виртуального DOM. Это сильно ускоряет их рендеринг.

- **См. также:** [Функциональные компоненты](../guide/render-function.html#Функциональные-компоненты)

## Свойства экземпляра

### vm.$data

- **Тип:** `Object`

- **Подробности:**

  Объект с данными, над которым экземпляр Vue осуществляет наблюдение. Экземпляр проксирует сюда вызовы своих полей. (Например, `vm.a` будет указывать на `vm.$data.a`)

- **См. также:** [Опции — данные](#data)

### vm.$el

- **Тип:** `HTMLElement`

- **Только для чтения**

- **Подробности:**

  Корневой элемент DOM, управляемый экземпляром Vue.

### vm.$options

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Опции, переданные в конструктор экземпляра Vue. Полезно, если вы хотите передавать туда собственные опции:

  ``` js
  new Vue({
    customOption: 'что-нибудь',
    created: function () {
      console.log(this.$options.customOption) // -> 'что-нибудь'
    }
  })
  ```

### vm.$parent

- **Тип:** `экземпляр Vue`

- **Только для чтения**

- **Подробности:**

  Экземпляр родителя, если он есть у текущего экземпляра.

### vm.$root

- **Тип:** `экземпляр Vue`

- **Только для чтения**

- **Подробности:**

  Корневой экземпляр Vue текущего дерева компонентов. Если у экземпляра нет родителя, в этом поле будет он сам.

### vm.$children

- **Тип:** `Array<экземпляр Vue>`

- **Только для чтения**

- **Подробности:**

  Компоненты-потомки экземпляра. **Обратите внимание, что порядок следования элементов в `$children` не гарантируется, и этот массив не реактивен.** Вместо того, чтобы использовать `$children` для связывания данных, попробуйте использовать обычный массив и директиву `v-for` для создания дочерних компонентов, и используйте этот массив как "источник истины".

### vm.$slots

- **Тип:** `{ [name: string]: ?Array<VNode> }`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к контенту, [распределяемому слотами](../guide/components.html#Распределение-контента-слотами). У каждого [именованного слота](../guide/components.html#Именованные-слоты) есть соответствующее значение (например, содержимое `slot="foo"` попадёт в `vm.$slots.foo`). Свойство `default` содержит узлы, не включённые в именованные слоты.

  Особенно полезно `vm.$slots` в компонентах с [render-функциями](../guide/render-function.html).

- **Пример:**

  ```html
  <blog-post>
    <h1 slot="header">
      Обо мне
    </h1>

    <p>Этот контент попадёт в vm.$slots.default, потому что он не в именованном слоте.</p>

    <p slot="footer">
      Copyright 2016 Evan You
    </p>

    <p>Этот контент тоже попадёт в vm.$slots.default.</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header),
        createElement('main', body),
        createElement('footer', footer)
      ])
    }
  })
  ```

  - [Компонент `<slot>`](#slot-1)
  - [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)
  - [Render-функции — слоты](../guide/render-function.html#Слоты)

### vm.$scopedSlots

> Добавлено в версии 2.1.0

- **Тип:** `{ [name: string]: props => VNode | Array<VNode> }`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к [слотам с ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости). Для каждого слота, включая и слот `default`, объект содержащий соответствующую функцию, что возвращает VNode.

  Использование `vm.$scopedSlots` наиболее полезно при написании компонентов с использованием [render-функций](../guide/render-function.html).

- **См. также:**
  - [`<slot>` компонент](#slot-1)
  - [Слоты с ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости)
  - [Render-функции — слоты](../guide/render-function.html#Слоты)


### vm.$refs

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Объект, с дочерними компонентами, имеющими параметр `ref`.

- **См. также:**
  - [Ссылки на компоненты-потомки](../guide/components.html#Ссылки-на-компоненты-потомки)
  - [ref](#ref)

### vm.$isServer

- **Тип:** `boolean`

- **Только для чтения**

- **Подробности:**

  Запущен ли данный экземпляр Vue на сервере.

- **См. также:** [SSR. Рендеринг на стороне сервера](../guide/ssr.html)

## Методы экземпляра — данные

<h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

- **Аргументы:**
  - `{string | Function} expOrFn`
  - `{Function} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Возвращает:** `{Function} unwatch`

- **Использование:**

  Запускает наблюдение за выражением или вычисляемой функцией на предмет изменений. В параметры коллбэка будут переданы новое и старое значения отслеживаемого объекта. Выражение может быть только простым путём до переменной с разделителями-точками. Для более сложных случаев используйте функцию.

  <p class="tip">Обратите внимание: когда изменяете (а не заменяете) объект или массив, старое и новое значения при вызове коллбэка будут совпадать, так как они ссылаются на один и тот же объект или массив. Vue не сохраняет копии объекта на момент, предшествовавший изменениям.</p>

- **Пример:**

  ``` js
  // следим за переменной, указанной путём:
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // переменная изменилась, сделайте что-нибудь
  })

  // следим за функцией:
  vm.$watch(
    function () {
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // значение функции изменилось, сделайте что-нибудь
    }
  )
  ```

  `vm.$watch` возвращает функцию unwatch, которая останавливает слежение:

  ``` js
  var unwatch = vm.$watch('a', cb)
  // позднее, останавливаем слежение:
  unwatch()
  ```

- **Опция: deep**

  Чтобы слежение реагировало на изменения во вложенных объектах, передайте `deep: true` в объекте параметров. Обратите внимание, что для наблюдения за изменениями массивов этого не требуется.

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // вызывается callback
  ```

- **Опция: immediate**

  Если передано `immediate: true`, коллбэк будет вызван сразу же после начала наблюдения с текущим значением выражения:

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // callback вызывается сразу, с текущим значением `a`
  ```

<h3 id="vm-set">vm.$set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  **Псевдоним** глобального метода `Vue.set`.

- **См. также:** [Vue.set](#Vue-set)

<h3 id="vm-delete">vm.$delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  **Псевдоним** глобального метода `Vue.delete`.

- **См. также:** [Vue.delete](#Vue-delete)

## Методы экземпляра — события

<h3 id="vm-on">vm.$on( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Создаёт подписку на пользовательское событие текущего vm. Такое событие можно породить функцией `vm.$emit`. Коллбэк получит все дополнительные аргументы, переданные этому методу.

- **Пример:**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'привет')
  // -> "привет"
  ```

<h3 id="vm-once">vm.$once( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Создаёт подписку на пользовательское событие, но срабатывает только один раз. После первого же использования подписчик будет удалён.

<h3 id="vm-off">vm.$off( [event, callback] )</h3>

- **Аргументы:**
  - `{string} [event]`
  - `{Function} [callback]`

- **Использование:**

  Удаляет подписчика или подписчиков события.

  - Если функция вызвана без параметров, она удалит все подписки на события;

  - Если указан только тип события — удалит все подписки указанного события;

  - Если указан и тип события, и коллбэк — будет удалена именно эта подписка именно этого события.

<h3 id="vm-emit">vm.$emit( event, [...args] )</h3>

- **Аргументы:**
  - `{string} event`
  - `[...args]`

  Порождает событие в текущем экземпляре. Все дополнительно указанные параметры будут переданы в коллбэк подписки.

## Методы экземпляра — жизненный цикл

<h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

- **Аргументы:**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Возвращает:** `vm` — сам экземпляр

- **Использование:**

  Если при создании экземпляра Vue не была указана опция `el`, он окажется в "непримонтированном" (unmounted) состоянии, то есть без ассоциированного элемента DOM. Вызовите `vm.$mount()`, чтобы примонтировать такой экземпляр.

  Если параметр `elementOrSelector` не указан, шаблон будет отрендерен как элемент вне документа. Вы сможете затем вставить такой элемент нативным интерфейсом DOM.

  Метод возвращает сам экземпляр, чтобы вы могли вызывать дополнительные методы по цепочке.

- **Пример:**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Привет!</div>'
  })

  // создаём и монтируем в #app (заменит #app):
  new MyComponent().$mount('#app')

  // другой вариант записи, делает то же самое:
  new MyComponent({ el: '#app' })

  // рендерим вне документа и вставляем в DOM позднее:
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [SSR. Рендеринг на стороне сервера](../guide/ssr.html)

<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

- **Использование:**

  Заставляет экземпляр Vue произвести перерендеринг. Обратите внимание, что этот метод затронет не все дочерние компоненты, а только сам экземпляр и дочерние компоненты с контентными слотами.

<h3 id="vm-nextTick">vm.$nextTick( [callback] )</h3>

- **Аргументы:**
  - `{Function} [callback]`

- **Использование:**

  Выполняет функцию `callback` при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM. Функция делает то же самое, что и глобальный `Vue.nextTick`, но кроме того связывает `this` с текущим экземпляром в коллбэке.

  > Добавлено в версии 2.1.0: возвращает `Promise`, если окружение их поддерживает и коллбэк не указан.

- **Пример:**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // меняем данные:
        this.message = 'changed'
        // DOM ещё не обновлён
        this.$nextTick(function () {
          // теперь DOM обновлён
          // `this` указывает на текущий экземпляр
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **См. также:**
  - [Vue.nextTick](#Vue-nextTick)
  - [Очередь асинхронных обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)

<h3 id="vm-destroy">vm.$destroy()</h3>

- **Использование:**

  Полностью уничтожает vm. Очищает связи с другими существующими vm, отвязывает директивы, отменяет все подписки на события.

  Вызывает хуки `beforeDestroy` и `destroyed`.

  <p class="tip">Как правило, вам не придётся вызывать этот метод самим. Лучше контролировать жизненный цикл дочерних компонентов в data-driven стиле директивами `v-if` и `v-for`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Директивы

### v-text

- **Принимает:** `string`

- **Подробности:**

  Управляет текстовым содержимым элемента (`textContent`). Если вам нужно управлять только частью содержимого тега, используйте интерполяцию `{% raw %}{{ Mustache }}{% endraw %}`.

- **Пример:**

  ```html
  <span v-text="msg"></span>
  <!-- то же, что -->
  <span>{{msg}}</span>
  ```

- **См. также:** [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Текст)

### v-html

- **Принимает:** `string`

- **Подробности:**

  Управляет HTML-содержимым элемента (`innerHTML`). **Обратите внимание, что содержимое вставляется как обычный HTML — то есть не компилируется как шаблон Vue**. Не стоит организовывать вложенные шаблоны с помощью `v-html`, попробуйте лучше применить компоненты.

  <p class="tip">Динамический рендеринг произвольного HTML-кода на сайте — это очень опасная практика, легко приводящая к [XSS-уязвимостям](https://en.wikipedia.org/wiki/Cross-site_scripting). Передавайте в `v-html` только содержимое, которому можно доверять, и **никогда** — необработанный пользовательский ввод.</p>

- **Пример:**

  ```html
  <div v-html="html"></div>
  ```
- **См. также:** [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Сырой-HTML)

### v-show

- **Принимает:** `any`

- **Использование:**

  Переключает CSS-свойство `display` элемента, в зависимости от того, истинно ли указанное выражение.

  При изменении состояния этой директивы вызываются анимации, заданные в transition.

- **См. также:** [Условный рендеринг — v-show](../guide/conditional.html#v-show)


### v-if

- **Принимает:** `any`

- **Использование:**

  Осуществляет рендеринг элемента, только если передаваемое выражение истинно. При изменении значения выражения на противоположное, элемент и содержащиеся в нём компоненты и директивы уничтожаются/пересоздаются. Если элемент — `<template>`, вместо него будет отрендерено его содержимое.

  Эта директива также запускает анимационные переходы при изменении условия.

  <p class="tip">При совместном использовании `v-if` и `v-for`, `v-for` имеет более высокий приоритет. Подробности на странице <a href="../guide/list.html#v-for-и-v-if">рендеринга списков</a>.</p>

- **См. также:** [Условный рендеринг — v-if](../guide/conditional.html#v-if)


### v-else

- **Не принимает какое-либо выражение**

- **Ограничение:** предыдущий элемент должен иметь директиву `v-if` или `v-else-if`.

- **Использование:**

  Определяет "блок else" для `v-if` или цепочки `v-if`/`v-else-if`.

  ```html
  <div v-if="Math.random() > 0.5">
    Сейчас меня видно
  </div>
  <div v-else>
    А сейчас — нет
  </div>
  ```

- **См. также:**
  - [Условный рендеринг — v-else](../guide/conditional.html#v-else)

### v-else-if

> Добавлено в версии 2.1.0

- **Ожидает:** `any`

- **Ограничение:** предшествующий элемент должен иметь `v-if` или `v-else-if`.

- **Использование:**

  Обозначает "блок else if" для `v-if`. Можно объединять в цепочки.

  ```html
  <div v-if="type === 'A'">
    A
  </div>
  <div v-else-if="type === 'B'">
    B
  </div>
  <div v-else-if="type === 'C'">
    C
  </div>
  <div v-else>
    Не A/B/C
  </div>
  ```

- **См. также:** [Условный рендеринг — v-else-if](../guide/conditional.html#v-else-if)

### v-for

- **Принимает:** `Array | Object | number | string`

- **Использование:**

  Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису `alias in expression` — в `alias` будет элемент текущей итерации:

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

   Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с объектом):

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, key, index) in object"></div>
  ```

  По умолчанию `v-for` будет пытаться обновить элементы "на месте", не перемещая их. Если вам нужно, чтобы элементы перемещались, сохраняя явную упорядоченность, укажите атрибут `key`:

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  <p class="tip">При совместном использовании `v-if` и `v-for`, `v-for` имеет более высокий приоритет. Подробности на странице <a href="../guide/list.html#v-for-и-v-if">рендеринга списков</a>.</p>

  Использование `v-for` подробно описано в секции руководства по ссылке ниже.

- **См. также:**
  - [Рендеринг списков](../guide/list.html)
  - [key](../guide/list.html#key)

### v-on

- **Сокращение:** `@`

- **Принимает:** `Function | Inline-выражение`

- **Параметр:** `event (обязательный)`

- **Модификаторы:**
  - `.stop` — вызовет `event.stopPropagation()`.
  - `.prevent` — вызовет `event.preventDefault()`.
  - `.capture` — добавит подписку в режиме capture.
  - `.self` — вызовет обработчик только если событие возникло непосредственно на этом элементе.
  - `.{keyCode | keyAlias}` — вызывает обработчик только при нажатии определённой клавиши.
  - `.native` — подписаться на нативное событие на корневом элементе компонента.
  - `.once` — вызовет обработчик не больше одного раза.

- **Использование:**

  Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

  У обычного элемента можно подписаться только **на нативные события DOM**. У элемента компонента можно также подписаться **на пользовательские события**, вызываемые этим дочерним компонентом.

  При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью `$event`: `v-on:click="handle('ok', $event)"`.

- **Пример:**

  ```html
  <!-- обработчик метода -->
  <button v-on:click="doThis"></button>

  <!-- inline-выражение -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- сокращённая запись -->
  <button @click="doThis"></button>

  <!-- модификатор stop propagation -->
  <button @click.stop="doThis"></button>

  <!-- модификатор prevent default -->
  <button @click.prevent="doThis"></button>

  <!-- модификатор prevent default без дополнительных действий -->
  <form @submit.prevent></form>

  <!-- цепочка из модификаторов -->
  <button @click.stop.prevent="doThis"></button>

  <!-- модификатор клавиши keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- модификатор клавиши keyCode -->
  <input @keyup.13="onEnter">

  <!-- обработчик метода будет вызван не больше одного раза -->
  <button v-on:click.once="doThis"></button>
  ```

  Подписка на пользовательское событие в дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает "my-event"):

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline-выражение -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- подписываемся на нативное событие в компоненте -->
  <my-component @click.native="onClick"></my-component>
  ```

- **См. также:**
  - [Обработка событий](../guide/events.html)
  - [Компоненты — пользовательские события](../guide/components.html#Пользовательские-события)

### v-bind

- **Сокращение:** `:`

- **Принимает:** `any (если указан параметр) | Object (если параметр не указан)`

- **Параметр:** `attrOrProp (опционально)`

- **Модификаторы:**
  - `.prop` — используется для связывания в качестве DOM-свойства, а не атрибута ([в чём разница?](http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028)).
  - `.camel` — преобразует имена атрибутов в kebab-case в camelCase (поддержка добавлена в версии 2.1.0).

- **Использование:**

  Динамически связывает атрибуты тега или входной параметр компонента с выражением.

  При использовании с атрибутами `class` и `style` поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.

  Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.

  Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты `class` и `style` не поддерживают массивы и объекты.

- **Пример:**

  ```html
  <!-- связывание атрибута -->
  <img v-bind:src="imageSrc">

  <!-- сокращение -->
  <img :src="imageSrc">

  <!-- поддержка конкатенации строк -->
  <img :src="'/path/to/images/' + fileName">

  <!-- связывание CSS-класса -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- связывание локального стиля -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- связывание с объектом, содержащим атрибуты -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- связывание с атрибутами DOM при указании модификатора -->
  <div v-bind:text-content.prop="text"></div>

  <!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
  <my-component :prop="someThing"></my-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

  Модификатор `.camel` позволяет перевод имени атрибута `v-bind` в camelCase при использовании DOM-шаблонов, например для атрибута `viewBox` SVG:

  ``` html
  <svg :view-box.camel="viewBox"></svg>
  ```

  В использовании `.camel` нет необходимости, если вы пользуетесь строковыми шаблонами или `vue-loader`/`vueify`.

- **См. также:**
  - [Работа с классами и стилями](../guide/class-and-style.html)
  - [Компоненты — входные параметры компонентов](../guide/components.html#Входные-параметры)


### v-model

- **Принимает:** разное, в зависимости от типа форм или выходных данных компонентов

- **Используется только с:**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - компонентами

- **Модификаторы:**
  - [`.lazy`](../guide/forms.html#lazy) — подписаться на события `change`, а не `input`
  - [`.number`](../guide/forms.html#number) — приводить введённую строку к числу
  - [`.trim`](../guild/forms.html#trim) — удалять пробелы в начале и в конце введённой строки

- **Использование:**

  Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива подробно описана в руководстве по ссылке ниже.

- **См. также:**
  - [Работа с формами](../guide/forms.html)
  - [Компоненты — поля ввода форм с использованием пользовательских событий](../guide/components.html#Поля-ввода-форм-с-использованием-пользовательских-событий)

### v-pre

- **Не принимает какое-либо выражение**

- **Использование:**

  Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов `{% raw %}{{}}{% endraw %}`. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

- **Пример:**

  ```html
  <span v-pre>{{ эта часть не будет скомпилирована }}</span>
   ```

### v-cloak

- **Не принимает какое-либо выражение**

- **Использование:**

  Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию. В сочетании с CSS-правилом  `[v-cloak] { display: none }` этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

- **Пример:**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  Элемент `<div>` не появится, пока компиляция не закончится.

### v-once

- **Не принимает какое-либо выражение**

- **Использование:**

  **Однократно** рендерит элемент или компонент. При повторном рендеринге он, а также все его потомки, рассматриваются как статический контент и пропускаются. Это поможет увеличить производительность обновлений.

  ```html
  <!-- одиночный элемент -->
  <span v-once>Это никогда не изменится: {{msg}}</span>

  <!-- элемент с потомком -->
  <div v-once>
    <h1>comment</h1>
    <p>{{msg}}</p>
  </div>

  <!-- компонент -->
  <my-component v-once :comment="msg"></my-component>

  <!-- директива v-for -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **См. также:**
  - [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Текст)
  - [Компоненты — дешёвые статические компоненты с v-once](../guide/components.html#“Дешёвые”-статические-компоненты-с-использованием-v-once)

## Специальные атрибуты

### key

- **Принимает:** `string`

  Атрибут `key` помогает алгоритму работы с виртуальным DOM определить, какие ноды соответствует какой строке данных. Если этот атрибут не указан, Vue использует алгоритм, минимизирующий перемещение элементов и старается обновить и повторно использовать как можно больше элементов правильного типа "на местах". А если ключ указан, Vue изменяет порядок следования элементов, основываясь на изменении порядка ключей. Элементы, соответствующие ключам, которых больше нет, Vue всегда уничтожает.

  Потомки одного и того же общего родителя должны иметь **уникальные ключи**. Повторяющиеся ключи приведут к ошибкам при рендеринге.

  Как правило, используется в связке с `v-for`:

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  Можно также применить эту директиву, чтобы элемент всегда заменялся на новый, а не переиспользовался. Это может помочь, если вы хотите:

  - Быть уверенным, что все хуки жизненного цикла компонента будут вызваны
  - Запускать анимации (например, установленные в transition)

  Например:

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  При изменении `text`, `<span>` всегда будет заменяться целиком, что спровоцирует вызов анимации.

### ref

- **Принимает:** `string`

  Название элемента или компонента для регистрации ссылки на него. В объекте `$refs` появится поле с названием из этого атрибута и значением: элементом DOM, если атрибут стоял на простом теге или экземпляром компонента, если атрибут стоял на пользовательском компоненте:

  ``` html
  <!-- vm.$refs.p будет DOM-элементом -->

  <p ref="p">hello</p>

  <!-- vm.$refs.child будет указывать на экземпляр ChildComp -->
  <child-comp ref="child"></child-comp>
  ```

  При использовании на элементах/компонентах с `v-for`, регистрируется массив ссылок на элементы DOM или экземпляры компонентов.

  Важное замечание о времени регистрации ссылок: поскольку ссылки создаются `render`-функцией, вы не cможете использовать их при первичном рендеринге — на тот момент они ещё не существуют! Кроме того, объект `$refs` не является реактивным, поэтому не стоит пытаться использовать его в шаблонах для связывания данных.

- **См. также:** [Ссылки на компоненты-потомки](../guide/components.html#Ссылки-на-компоненты-потомки)

### slot

- **Принимает:** `string`

  Используется в содержимом дочерних компонентов для указания того, к какому из именованных слотов принадлежит отмеченный контент.

  Подробнее в руководстве по ссылке ниже.

- **См. также:** [Именованные слоты](../guide/components.html#Именованные-слоты)

## Встроенные компоненты

### component

- **Входные параметры:**
  - `is` — string | ComponentDefinition | ComponentConstructor
  - `inline-template` — boolean

- **Использование:**

  "Метакомпонент" для рендеринга динамических компонентов. Настоящий компонент для рендеринга определяется параметром `is`:

  ```html
  <!-- динамический компонент, контролируемый -->
  <!-- свойством vm `componentId`-->
  <component :is="componentId"></component>

  <!-- может также рендерить зарегистрированный или переданный параметром компонент -->
  <component :is="$options.components.child"></component>
  ```

- **См. также:** [Динамическое переключение компонентов](../guide/components.html#Динамическое-переключение-компонентов)

### transition

- **Входные параметры:**
  - `name` — string, используется для автоматической генерации имён CSS-классов для анимаций. Например, `name: 'fade'` автоматически раскроется в `.fade-enter`, `.fade-enter-active` и т. д. Значение по умолчанию — `"v"`.
  - `appear` — boolean, вызывать ли анимацию при первом рендеринге. По умолчанию `false`.
  - `css` — boolean, применять ли CSS-классы. По умолчанию `true`. Если установить в `false`, будут вызываться только обработчики JavaScript, зарегистрированные для событий компонента.
  - `type` — string, указывает тип событий, с помощью которых определяется момент завершения анимации. Доступные значения: `"transition"` и `"animation"`. По умолчанию автоматически выбирается тип, задающий наибольшую продолжительность.
  - `mode` — string, управляет порядком анимаций исчезновения и появления элементов. Доступные режимы `"out-in"` (сначала старый элемент исчезает, потом новый появляется) и `"in-out"` (сначала новый элемент появляется, потом исчезает старый). По умолчанию исчезновение и появление происходят одновременно.
  - `enter-class` — string
  - `leave-class` — string
  - `appear-class` — string
  - `enter-to-class` — string
  - `leave-to-class` — string
  - `appear-to-class` — string
  - `enter-active-class` — string
  - `leave-active-class` — string
  - `appear-active-class` — string

- **События:**
  - `before-enter`
  - `before-leave`
  - `before-appear`
  - `enter`
  - `leave`
  - `appear`
  - `after-enter`
  - `after-leave`
  - `after-appear`
  - `enter-cancelled`
  - `leave-cancelled` (только для `v-show`)
  - `appear-cancelled`

- **Использование:**

  Указывает анимацию перехода для **одного** элемента или компонента. `<transition>` не порождает дополнительного элемента DOM при рендеринге, и не отображается в иерархии компонентов в инспекторе. Этот компонент просто применяет поведение перехода к своему содержимому.

  ```html
  <!-- простой элемент -->
  <transition>
    <div v-if="ok">переключаемое содержимое</div>
  </transition>

  <!-- динамический компонент -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- хук на событие -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">переключаемое содержимое</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // сделайте что-нибудь с переданным элементом DOM ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **См. также:** [Анимационные эффекты переходов: появление, исчезновение и списки](../guide/transitions.html)

### transition-group

- **Входные параметры:**
  - `tag` — string, по умолчанию используется `span`.
  - `move-class` — переопределяет CSS-класс, применяемый во время анимации перемещения.
  - те же атрибуты, что и у `<transition>` кроме `mode`.

- **События:**
  - те же, что и у `<transition>`.

- **Использование:**

  Указывает анимацию перехода для **нескольких** элементов или компонентов. `<transition-group>` превращается в реальный элемент DOM. По умолчанию для этого используется тег `<span>`, но можно указать любой другой в параметре `tag`.

  Обратите внимание, что каждый потомок `<transition-group>` должен иметь **уникальное значение key**, чтобы анимации работали корректно.

  Анимации перехода реализованы с помощью CSS-трансформаций. Когда позиция потомка изменилась после обновления, ему будет добавлен CSS-класс (автоматически сгенерированный из атрибута `name`, или же явно указанный в атрибуте `move-class`). Если после применения этого класса свойство `transform` можно будет анимировать, элемент будет с плавным переходом переведён туда, где он должен быть с помощью [техники FLIP](https://aerotwist.com/blog/flip-your-animations/).

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **См. также:** [Анимационные эффекты переходов: появление, исчезновение и списки](../guide/transitions.html)

### keep-alive

- **Props:**
  - `include` — строка или регулярное выражение. Только соответствующие компоненты будут кешироваться.
  - `exclude` — строка или регулярное выражение. Все соответствующие компоненты не будут кешироваться.

- **Использование:**

  Оберните динамические компоненты тегом `<keep-alive>`, чтобы кешировать экземпляры интерактивных компонентов вместо того, чтобы их уничтожать. Так же, как и `<transition>`, `<keep-alive>` — абстрактный компонент: при рендеринге он не превращается в элемент DOM, и не показывается в цепочке родителей компонента.

  Когда компонент, расположенный внутри `<keep-alive>` показывается или скрывается, вызываются его хуки жизненного цикла `activated` или `deactivated` соответственно.

  В основном используется для сохранения состояния компонента, чтобы избежать повторного рендеринга.

  ```html
  <!-- базовый вариант -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- несколько потомков -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- использование вместе с <transition> -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

- **`include` и `exclude`**

  > Добавлено в версии 2.1.0

  Входные параметры `include` и `exclude` позволяют организовать условное кеширование компонентов. Оба параметра можно указать в виде строки со списком имён компонентов через запятую, или регулярным выражением:

  ``` html
  <!-- строка с именами через запятую -->
  <keep-alive include="a,b">
    <component :is="view"></component>
  </keep-alive>

  <!-- регулярное выражение (используйте v-bind) -->
  <keep-alive :include="/a|b/">
    <component :is="view"></component>
  </keep-alive>
  ```

  Проверяется сначала собственное значение опции `name` компонента, а в случае его недоступности — имя, указанное при локальной регистрации (ключ в опции `components` компонента-родителя). Анонимные компоненты таким образом проверить не получится.

  <p class="tip">`<keep-alive>` не работает с функциональными компонентами, так как у них отсутствуют экземпляры.</p>

- **См. также:** [Динамическое переключение компонентов — keep-alive](../guide/components.html#keep-alive)

### slot

- **Входные параметры:**
  - `name` — string, используется для именования слотов

- **Использование:**

  `<slot>` — элемент, чьё содержимое будет распределено в шаблон компонента. Сам элемент `<slot>` при рендеринге заменяется.

  Подробнее этот механизм описан в руководстве по ссылке ниже.

- **См. также:** [Расределение контента слотами](../guide/components.html#Распределение-контента-слотами)

## Интерфейс VNode

- Смотрите информацию об [объявлении классов VNode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).

## Рендеринг на стороне сервера

- Смотрите [документацию пакета vue-server-renderer](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).
